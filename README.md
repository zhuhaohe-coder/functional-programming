# 编程范式

> 编程范式可以理解为编程的风格/方式，它决定了我们将以一种什么样的方法和规范去组织自己的代码，是一门研究“如何写代码”的学问。

**JS是多范式的语言**

- 命令式编程
- 面向对象式编程
- 函数式编程

> 函数式编程是一种==强调以函数使用为主==的软件开发风格。 ——[美]路易斯·阿泰西奥

## 函数式编程三大特征

- 拥抱纯函数, 隔离副作用
- 函数是"一等公民"
- 避免对状态的改变(不可变值)

# 纯函数与副作用

## 纯函数

同时满足以下两个特征的函数，我们就认为是纯函数：

- 对于相同的输入，总是会得到相同的输出
- 在执行过程中没有语义上可观察的副作用。

## 副作用

> 在计算机科学中，**函数副作用**指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科

简单地讲：对函数来说，它的正常工作任务就是【**计算**】，除了计算之外，它不应该搞别的。

**如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。**

## 纯与不纯的本质

**“纯”的本质——有且仅有【显式数据流】**

> 纯函数（Pure Function）——输入输出数据流全是**显式**（Explicit）的函数。
> —— 维基百科

数据以入参形式传入，这叫【显式输入数据流】。

数据以返回值形式输出，这叫【显式输出数据流】。

> 纯函数——**输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，==不以任何其它形式和外界进行数据交换==的函数**。

**“不纯”的元凶——隐式数据流**

一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

# 函数是一等公民

> 当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有**头等函数**。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。 ——MDN Web Docs

头等函数的核心特征是“**可以被当做变量一样用**”。

它意味着：

1. 可以被当做参数传递给其他函数
2. 可以作为另一个函数的返回值
3. 可以被赋值给一个变量

## “一等公民”的本质

为什么 JS 中的函数这么牛x，可以为所欲为呢？

本质上是因为**它不仅仅是个函数，它还是个(可执行的)对象**。

```js
const func = ()=>{}
undefined
func instanceof Function
true
func instanceof Object
true
Function instanceof Object
true
```

JavaScript 有且仅有以下 8 种数据类型：

基本类型:**大小固定、体积轻量、相对简单。**

- Undefined 类型
- Null 类型
- Boolean 类型
- Number 类型
- String 类型
- Symbol 类型
- BigInt类型

引用类型:**复杂、占用空间较大、且大小不定。**

- Object 类型

这两类数据之间最大的区别，在于**变量保存了数据之后，我们还能对这个数据做什么**。

> **并没有一种数据类型叫 Function**，Function 和 Array、Date 这些 built-in Class 一样，都属于对象类型。
>
> 既然函数也是对象，那么对象能干的事，函数也能干。

# 不可变数据

> “不可变数据”正如一顶牢牢扣在我们程序员脑袋上的**安全帽**，它从实践的角度，对我们的编码行为作出了更加具体的约束，确保我们能够最大限度地输出纯净、安全的代码。

## 不可变的值

**值类型的数据无法被修改**，当我们修改值类型变量的时候，本质上会创建一个新的值。

```js
let a = 1
let b = a

// true
a === b

b = 2

// false
a === b
```

**像数字类型这样，自创建起就无法再被修改的数据，我们称其为“不可变数据**”。

## 可变的引用内容

**在引用本身不变的情况下，引用所指向的内容是可以发生改变的。**

```js
const a = {
  name: 'xiuyan',
  age: 30
}

const b = a


// true 
a === b 

b.name = 'youhu'   
 
// true
a === b 
```

**像这种创建后仍然可以被修改的数据，我们称其为“可变数据”。**

## 为什么函数式编程不喜欢可变数据

### 可变数据使函数行为变得难以预测

可变数据会使数据的变化变得隐蔽，进而使函数的行为变得难以预测。

在函数式编程这种范式下，我们校验一个函数有效性的关键依据，永远是“**针对已知的输入，能否给出符合预期的输出**”，这样的校验非常清晰、且容易实现。

而可变数据的出现则将会使函数的作用边界变得模糊，进而导致使用者、甚至开发者自身都难以预测它的行为最终会指向什么样的结果。

### 可变数据使函数复用成本变高

可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。

但很多情况下，当我们使用某一个函数的时候，我们会默认它是一个黑盒——无论是我今天去 npm 上拉下来一个第三方包，还是说我去其他业务的文件夹下借隔壁老王写的函数来用，我们关注的都是这个**函数的效用、函数的输入与输出，而不会去关注它的实现细节**。

就好像我们使用酸奶机之前，最多读一下说明书，而不会拆开它的壳子研究一下它装了几根电阻丝一样。

因此，我们有必要确保，这个黑盒是可靠的、受控的。

**一个可靠、受控的黑盒，应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西**。
这就像我们往酸奶机里倒入了酵母和牛奶，只期望它能产出酸奶，而不希望它引燃旁边的烤箱一样。

要想做到这一点，就必须**把可变数据从我们的函数代码里铲除干净。**

## 实践原则: 拷贝,而不是修改

### 拷贝的目的：确保外部数据的只读性

对于函数式编程来说，**函数的外部数据是只读的，函数的内部数据则是可写的**。

对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些**外部数据**，存在【只读】的必要。

> 注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。

### 拷贝不是万能解药

当**数据规模大、数据拷贝行为频繁**时，拷贝将会给我们的应用性能带来巨大的挑战。

拷贝出来的冗余数据将盘踞大量的内存，挤占其它任务的生存**空间**；此外，拷贝行为本身也是需要吃 CPU 的，持续而频繁的拷贝动作，无疑将拖慢应用程序的反应**速度**。

因此，对于**状态简单、逻辑轻量**的应用来说，拷贝确实是一剂维持数据不可变性的良药。

但是对于**数据规模巨大、数据变化频繁**的应用来说，拷贝意味着一场性能灾难。

## 持久化数据结构

### Immutable.js

> ImmutableJS 是对“不可变值”这一思想的贯彻实践。它在 2014 年被 Facebook 团队推出，Facebook 给它的定位是“实现持久化数据结构的库”。

mmutable.js 提供了一系列的 Api，这些 Api 将帮助我们确保数据的不可变性。

从代码上来看，它省掉了我们手动拷贝的麻烦。

从效率上来说，它在**底层应用了持久化数据结构，解决了暴力拷贝带来的各种问题**。

### Git “快照”是如何工作的

在创建 commit 时，git 会对整个项目的所有文件做一个“快照”。

“快照”记录的并不是文件的内容，而是**文件的索引**。

当 commit 发生时， git 会保存当前版本所有文件的索引。

**对于那些没有发生变化的文件，git 保存他们原有的索引；对于那些已经发生变化的文件，git 会保存变化后的文件的索引。**

假设一个项目中有 A、B 两个文件，其中 A 文件被修改了，而 B 文件保持不变。

我们将修改后的新的 A 文件的索引记为 A'

在变化发生后，A 和 A' 是共存的，变化前的那一次快照指向 A，变化后的这一次快照指向 A'。

而未被修改到的 B 文件，将会原封不动地呆在原地，被新版本的快照所复用，如下图所示：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bd7ddec61a48aa8ba293694f5707cc~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

**快照的本质是对索引的记录。**

### 理解“数据共享”：从“快照”到“安全帽”

和 git “快照”一样，持久化数据结构的精髓同样在于“**数据共享**”。

数据共享意味着将“变与不变”分离，确保**只有变化的部分被处理，而不变的部分则将继续留在原地、被新的数据结构所复用。**

