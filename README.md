# 编程范式

> 编程范式可以理解为编程的风格/方式，它决定了我们将以一种什么样的方法和规范去组织自己的代码，是一门研究“如何写代码”的学问。

**JS是多范式的语言**

- 命令式编程
- 面向对象式编程
- 函数式编程

> 函数式编程是一种==强调以函数使用为主==的软件开发风格。 ——[美]路易斯·阿泰西奥

## 函数式编程三大特征

- 拥抱纯函数, 隔离副作用
- 函数是"一等公民"
- 避免对状态的改变(不可变值)

# 纯函数与副作用

## 纯函数

同时满足以下两个特征的函数，我们就认为是纯函数：

- 对于相同的输入，总是会得到相同的输出
- 在执行过程中没有语义上可观察的副作用。

## 副作用

> 在计算机科学中，**函数副作用**指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科

简单地讲：对函数来说，它的正常工作任务就是【**计算**】，除了计算之外，它不应该搞别的。

**如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。**

## 纯与不纯的本质

**“纯”的本质——有且仅有【显式数据流】**

> 纯函数（Pure Function）——输入输出数据流全是**显式**（Explicit）的函数。
> —— 维基百科

数据以入参形式传入，这叫【显式输入数据流】。

数据以返回值形式输出，这叫【显式输出数据流】。

> 纯函数——**输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，==不以任何其它形式和外界进行数据交换==的函数**。

**“不纯”的元凶——隐式数据流**

一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

# 函数是一等公民

> 当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有**头等函数**。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。 ——MDN Web Docs

头等函数的核心特征是“**可以被当做变量一样用**”。

它意味着：

1. 可以被当做参数传递给其他函数
2. 可以作为另一个函数的返回值
3. 可以被赋值给一个变量

## “一等公民”的本质

为什么 JS 中的函数这么牛x，可以为所欲为呢？

本质上是因为**它不仅仅是个函数，它还是个(可执行的)对象**。

```js
const func = ()=>{}
undefined
func instanceof Function
true
func instanceof Object
true
Function instanceof Object
true
```

JavaScript 有且仅有以下 8 种数据类型：

基本类型:**大小固定、体积轻量、相对简单。**

- Undefined 类型
- Null 类型
- Boolean 类型
- Number 类型
- String 类型
- Symbol 类型
- BigInt类型

引用类型:**复杂、占用空间较大、且大小不定。**

- Object 类型

这两类数据之间最大的区别，在于**变量保存了数据之后，我们还能对这个数据做什么**。

> **并没有一种数据类型叫 Function**，Function 和 Array、Date 这些 built-in Class 一样，都属于对象类型。
>
> 既然函数也是对象，那么对象能干的事，函数也能干。

# 不可变数据

> “不可变数据”正如一顶牢牢扣在我们程序员脑袋上的**安全帽**，它从实践的角度，对我们的编码行为作出了更加具体的约束，确保我们能够最大限度地输出纯净、安全的代码。

## 不可变的值

**值类型的数据无法被修改**，当我们修改值类型变量的时候，本质上会创建一个新的值。

```js
let a = 1
let b = a

// true
a === b

b = 2

// false
a === b
```

**像数字类型这样，自创建起就无法再被修改的数据，我们称其为“不可变数据**”。

## 可变的引用内容

**在引用本身不变的情况下，引用所指向的内容是可以发生改变的。**

```js
const a = {
  name: 'xiuyan',
  age: 30
}

const b = a


// true 
a === b 

b.name = 'youhu'   
 
// true
a === b 
```

**像这种创建后仍然可以被修改的数据，我们称其为“可变数据”。**

## 为什么函数式编程不喜欢可变数据

### 可变数据使函数行为变得难以预测

可变数据会使数据的变化变得隐蔽，进而使函数的行为变得难以预测。

在函数式编程这种范式下，我们校验一个函数有效性的关键依据，永远是“**针对已知的输入，能否给出符合预期的输出**”，这样的校验非常清晰、且容易实现。

而可变数据的出现则将会使函数的作用边界变得模糊，进而导致使用者、甚至开发者自身都难以预测它的行为最终会指向什么样的结果。

### 可变数据使函数复用成本变高

可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。

但很多情况下，当我们使用某一个函数的时候，我们会默认它是一个黑盒——无论是我今天去 npm 上拉下来一个第三方包，还是说我去其他业务的文件夹下借隔壁老王写的函数来用，我们关注的都是这个**函数的效用、函数的输入与输出，而不会去关注它的实现细节**。

就好像我们使用酸奶机之前，最多读一下说明书，而不会拆开它的壳子研究一下它装了几根电阻丝一样。

因此，我们有必要确保，这个黑盒是可靠的、受控的。

**一个可靠、受控的黑盒，应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西**。
这就像我们往酸奶机里倒入了酵母和牛奶，只期望它能产出酸奶，而不希望它引燃旁边的烤箱一样。

要想做到这一点，就必须**把可变数据从我们的函数代码里铲除干净。**

## 实践原则: 拷贝,而不是修改

### 拷贝的目的：确保外部数据的只读性

对于函数式编程来说，**函数的外部数据是只读的，函数的内部数据则是可写的**。

对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些**外部数据**，存在【只读】的必要。

> 注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。

### 拷贝不是万能解药

当**数据规模大、数据拷贝行为频繁**时，拷贝将会给我们的应用性能带来巨大的挑战。

拷贝出来的冗余数据将盘踞大量的内存，挤占其它任务的生存**空间**；此外，拷贝行为本身也是需要吃 CPU 的，持续而频繁的拷贝动作，无疑将拖慢应用程序的反应**速度**。

因此，对于**状态简单、逻辑轻量**的应用来说，拷贝确实是一剂维持数据不可变性的良药。

但是对于**数据规模巨大、数据变化频繁**的应用来说，拷贝意味着一场性能灾难。

## 持久化数据结构

### Immutable.js

> ImmutableJS 是对“不可变值”这一思想的贯彻实践。它在 2014 年被 Facebook 团队推出，Facebook 给它的定位是“实现持久化数据结构的库”。

mmutable.js 提供了一系列的 Api，这些 Api 将帮助我们确保数据的不可变性。

从代码上来看，它省掉了我们手动拷贝的麻烦。

从效率上来说，它在**底层应用了持久化数据结构，解决了暴力拷贝带来的各种问题**。

### Git “快照”是如何工作的

在创建 commit 时，git 会对整个项目的所有文件做一个“快照”。

“快照”记录的并不是文件的内容，而是**文件的索引**。

当 commit 发生时， git 会保存当前版本所有文件的索引。

**对于那些没有发生变化的文件，git 保存他们原有的索引；对于那些已经发生变化的文件，git 会保存变化后的文件的索引。**

假设一个项目中有 A、B 两个文件，其中 A 文件被修改了，而 B 文件保持不变。

我们将修改后的新的 A 文件的索引记为 A'

在变化发生后，A 和 A' 是共存的，变化前的那一次快照指向 A，变化后的这一次快照指向 A'。

而未被修改到的 B 文件，将会原封不动地呆在原地，被新版本的快照所复用，如下图所示：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bd7ddec61a48aa8ba293694f5707cc~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

**快照的本质是对索引的记录。**

### 理解“数据共享”：从“快照”到“安全帽”

和 git “快照”一样，持久化数据结构的精髓同样在于“**数据共享**”。

数据共享意味着将“变与不变”分离，确保**只有变化的部分被处理，而不变的部分则将继续留在原地、被新的数据结构所复用。**

## Immer.js

Immer.js 实现 Immutability 的姿势非常有趣——它使用 Proxy，对目标对象的行为进行“元编程”。

所谓“元编程”，指的是对编程语言进行再定义。

### 回顾Proxy

> Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 ——MDN

借助 Proxy，我们可以给目标对象创建一个代理（拦截）层、拦截原生对象的某些默认行为，进而实现对目标行为的自定义。

### Produce 工作原理：将拷贝操作精准化

`produce` 可以像 Immutable.js 一样，精准打击那些需要执行写操作的数据。**将“变与不变”分离，确保只有变化的部分被处理，而不变的部分则将继续留在原地。**

但 `produce` 并没有像 Immutable.js 一样打数据结构的主意，而是将火力集中对准了“拷贝”这个动作。

它严格地控制了“拷贝”发生的时机：**当且仅当写操作确实发生时，拷贝动作才会被执行。**

```js
const baseHandler = {
  set(obj, key, value) {
    // 先检查 copy 是否存在，如果不存在，创建 copy
    if (!copy) {
      copy = { ...base }
    }
    // 如果 copy 存在，修改 copy，而不是 base
    copy[key] = value
    return true
  }
}
```

在我们的极简版 `produce` 里，着重突出了 `setter` 函数的写逻辑，也就是对“拷贝时机”的描述，淡化了其它执行层面的细节。

而在 Immer.js 中，完整版 `produce` 的浅拷贝其实是**可递归**的。

`produce` **不仅会拦截** `setter` **，也会拦截** `getter`。

通过对 `getter` 的拦截，`produce` 能够按需地对被访问到的属性进行“懒代理”：你访问得有多深，代理逻辑就能走多深；而所有被代理的属性，都会具备新的 `setter` 方法。

当写操作发生时，`setter` 方法就会被逐层触发，呈现“逐层浅拷贝”的效果。

**“逐层浅拷贝”是 Immer 实现数据共享的关键。**

假设我的对象嵌套层级为 10 层，而我对它的属性修改只会触达第 2 层，“逐层的浅拷贝”就能够帮我们确保拷贝只会进行到第 2 层。

“逐层的浅拷贝”如果递归到最后一层，就会变成深拷贝。

对于引用类型数据来说，“暴力拷贝”指的也就是深拷贝。

“暴力拷贝”之所以会带来大量的时间空间上的浪费，本质上是因为它在拷贝的过程中不能够“**知其所止**”。

而“逐层的浅拷贝”之所以能够实现数据共享，正是因为它借助 Proxy 做到了“**知其所止**”。

### “知其所止”的软件设计表达

无论是“精准拷贝”、“修改时拷贝”，还是“逐层拷贝”，其背后体现的都是同一个思想——“按需”。

“知其所止”的软件设计表达，就是“按需”。

对于 Immutable.js 来说，它通过构建一套原生 JS 无法支持的 Trie 数据结构，最终实现了树节点的按需创建。

对于 Immer.js 来说，它借助 Proxy 的 getter 函数实现了按需代理，借助 Proxy 的 setter 函数实现了对象属性的按需拷贝。

可见，想要实现高效的 Immutability，“按需变化”是一个不错的切入点。

## Immutability 的实践演进

对于 JS 来说，Immutability 实践的直接目的是什么？

简单来说，是为了解决**数据内容变化与数据引用变化不同步的问题**。

我拿到一个引用类型数据（`A`)，修改了其中的一个 `a` 属性，然后所有依赖 `A.a` 进行计算的函数逻辑全炸了，牵一发而动全身，这不是我们想要的结局。

我们希望一旦引用类型数据（`A`）的内容改变了，我们就能获取到一个新的引用，这个引用指向一套已经发生改变的数据（`A'`)， `A` 和 `A'` 应该是泾渭分明的。

**暴力拷贝，可以做到“泾渭分明”，但是对于规模较大的数据来说，它太低效了**。

于是，社区的 Immutability 解决方案百花齐放，Immer.js 和 Immutable.js 就是其中的佼佼者。

**Immutable.js 底层是持久化数据结构，而 Immer.js 的底层是 Proxy 代理模式。**

两者虽然在具体的工作原理上大相径庭，但最终指向的目的却是一致的：**使数据的引用与数据内容的变化同步发生；并且在这个过程中，按需处理具体的变化点，提升不可变数据的执行效率。**

# 因为DRY,所以HOF

> DRY(Don't Repeat Yourself) 是一种软件设计原则，HOF(High Order Function)指高阶函数。

**高阶函数，指的就是接收函数作为入参，或者将函数作为出参返回的函数。**

## WHY HOF

- 更简洁的代码,方便读写
- 更小的编码负担
- 更好的可读性
- 代码可复用, 利人利己
- 清晰的逻辑边界, 更少的测试工作

# "万金油"Reduce

> `reduce()`**是函数式语言的万金油；函数式语言不能失去** `reduce()`**，就像西方不能失去耶路撒冷。**

**在 JS 中，基于 reduce()，我们不仅能够推导出其它数组方法，更能够推导出经典的函数组合过程。**

## 使用reduce推导map

```js
const reduceToMap = (arr, fn) => {
  return arr.reduce((pre, cur) => {
    pre.push(fn(cur));
    return pre;
  }, []);
};
```

`map()` 过程可以看作是 `reduce()` 过程的一种特殊的应用。

也就是说，在数组方法里，`reduce()` 处在逻辑链相对底层的位置，这一点毋庸置疑。

`reduce()`**真正的威力，在于它对函数组合思想的映射。**

## `reduce()` 映射了函数组合思想

`reduce()` 的工作流：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd3b69f006824035ac674303fe2c0feb~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

通过观察这个工作流，我们可以发现这样两个特征：

- `reduce()` 的回调函数在做参数组合
- `reduce()` 过程构建了一个函数 pipeline

### `reduce()` 的回调函数在做参数组合

首先，就 reduce() 过程中的单个步骤来说，每一次回调执行，都会吃进 2 个参数，吐出 1 个结果。

我们可以把每一次的调用看做是把 2 个入参被【**组合**】进了 callback 函数里，最后转化出 1 个出参的过程。

我们把数组中的 n 个元素看做 n 个参数，那么 `reduce()` 的过程，就是一个把 n 个参数逐步【**组合**】到一起，最终吐出 1 个结果的过程。

reduce，动词，意为减少。这个【减少】可以理解为是参数个数的减少。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc3554f1f1245c5bdaa8d3647411b90~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

如上图所示，reduce 方法把多个入参，reduce（减少）为一个出参 。

### `reduce()` 过程是一个函数 pipeline

`reduce()` 函数发起的工作流，可以看作是一个函数 pipeline。

尽管每次调用的都是同一个函数，但**上一个函数的输出，总是会成为下一个函数的输入。**

同时，`reduce()` pipeline 里的每一个任务都是一样的，仅仅是入参不同，**这极大地约束了 pipeline 的能力**。

我们把 `reduce()` 的这两个特征放在一起来看：**参数组合+函数pipeline**。

咱就是说，有没有可能，有没有可能咱们把 pipeline 里的每一个函数也弄成不一样的呢？

更直白地说，你`reduce()`既然都能组合参数了，你能不能帮我的 pipeline 组合一下函数呢？

毕竟，**JS 的函数是可以作为参数传递**的嘛！

答案是肯定的——可能，可太能了！

`reduce()` 之所以能够作为函数式编程的“万金油”存在，本质上就是因为它映射了函数组合的思想。

而函数组合，恰恰是函数式编程中最特别、最关键的实践方法，是核心中的核心，堪称“核中核”。

### 借助reduce推导函数组合

一旦我们可以把 reduce pipeline 里的最小计算单元修改成任意不同的函数，那么`reduce`的工作流就会变成下面这样了

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0eed4a85a54046b0c8ee9e7ef679ed~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

只要我们能够想办法**让 reduce 工作流里的计算单元从一个函数转变为 N 个函数**，我们**就可以达到函数组合的目的**。

在整个 reduce 的工作流中，callback 是锁死的，但每次调用 callback 时传入的参数是动态可变的（如下图）。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5509a0c9e04d8f8cc7a417ccb19ccc~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

我们把**待组合的函数放进一个数组里，然后调用这个函数数组的 reduce 方法**，就可以创建一个多个函数组成的工作流。

而这，正是市面上主流的函数式库实现 compose/pipe 函数的思路。

### 借助reduce推导pipe

```js
const funcs = [func1, func2, func3]
```

我们假设三个 func 均是用于数学计算的函数，整个工作流的任务就是吃进一个数字 0 作为入参、吐出一个计算结果作为出参。

我想要逐步地组合调用 funcs 数组里的函数，得到一个这样的声明式数据流：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9a8c25da8e44fcab4ab393e40a6a49~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

如果我借助了 reduce，我得到的数据流乍一看和楼上是有出入的：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc6e25ab292b433389d99280058d169b~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

如何通过调整 reduce 的调用，使它的工作流和声明式数据流看齐呢？

首先是入参的对齐，这个比较简单，我们只需要把 initialValue 设定为 0 就可以了。

入参明确后，我的 reduce 调用长这样：

```js
const funcs = [func1, func2, func3]  

funcs.reduce(callback, 0)
```

接下来重点在于 callback 怎么实现

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71658f7803864aa999f8e33370b5e93f~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

想要让上下两个流程等价，我们只需要确保红蓝两个圈圈的工作内容总是等价就可以了。

从第一对红蓝圈圈开始看起，蓝色圈圈的工作内容是 func1(0)，红色圈圈的工作内容是 callback(0, func1)。

两者等价，意味着 callback(0, func1) = func1(0)。

同理，我们可以逐步推导出第二个、第三个红色圈圈的工作内容，分别应该满足：

callback(value1, func2) = func2(value1)

callback(value2, func3) = func3(value2)

以此类推，对于任意的入参 (input, func），callback 都应该满足：

callback(input, func) = func(input)

```js
function callback(input, func) {
  func(input)
}  

funcs.reduce(callback,0)
```

再稍微包装一下，给这坨逻辑起一个新名字：

```js
function pipe(...funcs) {
  function callback(input, func) {
    return func(input)
  }  

  return function(param) {
    return funcs.reduce(callback,param)
  }
}
```

我们就得到了一个经典的 pipe 函数。

## compose : 倒序的pipe

pipe 用于创建一个正序的函数传送带，而 compose 则用于创建一个倒序的函数传送带。

我们把 pipe 函数里的 reduce 替换为 reduceRight，就能够得到一个compose：

```js
function compose(...funcs) {
  function callback(input, func) {
    return func(input)
  }  

  return function(param) {
    return funcs.reduceRight(callback,param)
  }
}
```

**正序是 pipe，倒序是 compose。**

# 声明式数据流

## 借助链式调用构建声明式数据流

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8];
/*
筛选出 arr 里大于 2 的数字
将步骤1中筛选出的这些数字逐个乘以 2
对步骤 2 中的偶数数组做一次求和
*/
const arrMoreThan2 = arr.filter((item) => item > 2);
const arrMutile2 = arrMoreThan2.map((item) => item * 2);
const arrSum = arrMutile2.reduce((pre, cur) => {
  return pre + cur;
}, 0);
console.log(arrSum);//66

//code review
/*
 1.简洁性:
 冗余常量arrMoreThan2,arrMutile2(计算中间态)
 拉垮了代码的可读性

 2.安全性:
 arrMoreThan2,arrMutile2作为引用类型,完全有可能在运行过程中被修改
 不要抱计算中间态暴露出去
*/
//优化
const biggerThan2 = (num) => num > 2;
const mutile2 = (num) => num * 2;
const add = (a, b) => a + b;
const sum = arr.filter(biggerThan2).map(mutile2).reduce(add, 0);
console.log(sum);//66
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e1de59b45848e0982ba71d67c99de3~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

**借助链式调用，足以完美地规避掉那些尴尬的“中间态”，从而确保我们的代码简洁安全。**

过去，我有三行代码，我需要逐行阅读、理解计算中间态和主流程之间的逻辑关系，才能够推导出程序的意图。**这样的代码，是命令式的。**

现在，我只需要观察一个函数调用链，这个调用链如同一条传送带一般，用函数名标注了每道工序的行为。即便不清楚数据到底是如何在“传送带”上流转的，我们也能够通过函数名去理解程序的意图。

**这样的代码，是声明式的。** 基于此构建出的数据流，就是**声明式的数据流**。

**实现声明式的数据流，除了借助链式调用，还可以借助函数组合。**

### 链式调用的前提

map()、reduce()、filter() 这些方法之间，之所以能够进行链式调用，是因为：

1. 它们都**挂载在 Array 原型的 Array.prototype** 上
2. 它们在计算结束后都会 return 一个新的 Array
3. 既然 return 出来的也是 Array，那么自然可以继续访问原型 **Array.prototype** 上的方法

链式调用的本质 **，是通过在方法中==返回对象实例本身的 this/ 与实例 this 相同类型的对象==，达到多次调用其原型（链）上方法的目的。**

要对函数执行链式调用，**前提是==函数挂载在一个靠谱的宿主 Object 上==。**

## 独立函数的组合姿势

```js
function add4(num) {
  return num + 4;
}

function multiply3(num) {
  return num * 3;
}

function divide2(num) {
  return num / 2;
}
//如何基于这些独立函数，构建一个多个函数串行执行的工作流？
```

### 组合，但是回调地狱版

```js
// 1.套娃--反复去嵌套各种回调函数  回调地狱
const res = add4(multiply3(divide2(10)));
console.log(res);
```

### 使用reduce构建的pipe函数

```js
function pipe(...funcs) {
  function callback(input, func) {
    return func(input);
  }
  return function (param) {
    return funcs.reduce(callback, param);
  };
}
function add4(num) {
  return num + 4;
}

function multiply3(num) {
  return num * 3;
}

function divide2(num) {
  return num / 2;
}
const computed = pipe(add4, multiply3, divide2);
console.log(computed(10));
```

## Why Compose?

面向对象的核心在于继承，而**函数式编程的核心则在于组合**。

我们常说函数式编程就像一个乐高游戏：那一个个独立内聚的函数就像一堆乐高积木方块儿。它们看似渺小到无足轻重，却可以在**组合**后变幻出千百种形态、最终呈现出复杂而强大的功能。

组合这个动词，赋予了函数式编程无限的想象力和可能性。

在函数式编程的实践中，我们正是**借助 compose 来组合多个函数的功能**，它**是函数式编程中最有代表性的一个工具函数**，所以它才会成为面试题中的常客。

# 多元函数解决方案:从编码工具视角看待偏函数&柯里化

偏函数和柯里化解决的最核心的问题有两个，分别是：

- 函数组合链中的多元参数问题
- 函数逻辑复用的问题

## 函数组合链中的多元参数问题

### 理解函数中的"元数(Arity)"

函数参数里的“元数”，指的其实就是函数参数的数量。

### 函数组合链中的参数对齐问题

函数组合虽好，但各种限制少不了。

上一节中的pipe函数中, 调用链的三个函数齐刷刷都是一元函数,这个属于是理想情况了。有的时候，一个调用链中的函数彼此之间可能并没有这么和谐。

对于函数组合链来说，它总是预期链上的函数是一元函数：函数吃进一个入参，吐出一个出参，然后这个出参又会作为下一个一元函数的入参......参数个数的对齐，是组合链能够运转的前提。

**一旦链上乱入了多元函数，那么多元函数的入参数量就无法和上一个函数的出参数量对齐，进而导致执行错误。**

> tips：==函数组合链上的函数总是一元函数==，这是一个通用且广泛的约定，但并不是一个“死规矩”。
> 有时候，我们可以通过适当的改造，使组合链接受多元函数。比如 ramda.js 中的 pipe 函数，就允许链上的第一个函数有任意多个参数（注意，仅仅是第一个函数有此“特权”，其余函数仍然必须是一元函数）。

**任何时候，只要我们想要对函数的入参数量进行改造，必须先想到偏函数&柯里化。**

## 求解多元参数问题

### 柯里化的概念与实现

> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

具体一点，就是说柯里化是一个把 `fn(a, b, c)`转化为`fn(a)(b)(c)`的过程。

举个例子，我有一个函数，可以将任意三个数相加：

```js
function addThreeNum(a, b, c) {
  return a+b+c
}
```

正常调用的话就是 `addThreeNum(1, 2, 3)` 这样的。

但是通过柯里化，我可以把调用姿势改造为 `addThreeNum(1)(2)(3)`。

有没有什么姿势，可以允许我在**保留原有函数的基础上，单纯通过增量代码来实现柯里化**呢？

当然有啦！高阶函数不就是干这个的么！

下面我就针对加法这个场景，创建了一个名为 curry 的高阶函数（解析在注释里）：

```js
// 定义高阶函数 curry
function curry(addThreeNum) {
  // 返回一个嵌套了三层的函数
  return function addA(a) {
    // 第一层“记住”参数a
    return function addB(b) {
      // 第二层“记住”参数b
      return function addC(c) {
        // 第三层直接调用现有函数 addThreeNum
        return addThreeNum(a, b, c)
      }
    }
  }
}

// 借助 curry 函数将 add
const curriedAddThreeNum = curry(addThreeNum)
// 输出6，输出结果符合预期
curriedAddThreeNum(1)(2)(3)
```

### 偏函数 VS 柯里化

> 在计算机科学中，**部分应用**（或部分函数应用）指的是将一些参数固定在一个函数上，产生另一个较小元的函数的过程。

> tips: 偏函数英文是 partial application， 直译过来就是“部分应用”。

偏函数是指通过**固定函数的一部分参数**，生成一个**参数数量更少的函数**的过程。

柯里化说的是一个 n 元函数变成 n 个一元函数。

偏函数说的是一个 n 元函数变成一个 m(m < n） 元函数。

对于柯里化来说，不仅函数的元发生了变化，函数的数量也发生了变化（1个变成n个）。

对于偏函数来说，仅有函数的元发生了变化（减少了），函数的数量是不变的。

#### 偏函数求解组合链中的参数对齐问题

```js
function mutiply(a, b) {
  return a * b;
}
function wrapFunc(fn, fixedValue) {
  return (input) => {
    return fn(fixedValue, input);
  };
}
const mutiply3 = wrapFunc(mutiply, 3);
console.log(mutiply3(2));
```

这样就成功固定了 `multiply` 函数的第一个入参 x，得到了一个一元函数 `multiply3`，这完全符合组合链对函数元的预期。

## 函数逻辑复用问题

当我们看到偏函数和柯里化的实现分别都借助了**高阶函数**后，“逻辑复用”几乎是一件不言而喻的事情了。

### 参数固定-复用存量逻辑

在 multiply3 这个例子中，偏函数除了解决了**函数的元的问题**，还充分地**对现有逻辑进行了复用**。

multiply 函数是一个存量函数，我们的目标函数 **multiply3 其实可以看作是 multiply 函数功能的一个子集**。

这种情况下，与其单独定义一个 `multiply3`，不如试着通过偏函数处理实现对存量逻辑 **`multiply`** 的定制。

`multiply3`、`multiply` 两个函数的逻辑都不算复杂，复用带来的利好体现得还不算特别明显。

但在实际的应用中，我们的存量函数逻辑可以是非常复杂的。

```js
function generateOrderData(type, area, settlement) {
  // 省略数十行难以理解的业务逻辑......
}
```

`generateOrderData` 通过读取订单类型、订单地区、订单结算信息等参数，对订单信息进行重构，最终输出一套能够供 UI 层直接消化的渲染数据。

这样一个函数的改造成本是很高的。

如果我们遇到一个场景，期望能够针对某一个特定区域、特定类型的订单数据进行计算（也就是固定 `type`、`area` 这两个参数），对应函数名为 `generateSpecOrderData(settlement)`。

相比于参考 `generateOrderData` 的具体逻辑重新写一个 `generateSpecOrderData` 出来，直接在 `generateOrderData` 的基础上做偏函数处理不仅可以帮助我们避免大量的重复代码，同时也省去了读函数、理解函数的时间成本——毕竟，**做偏函数处理只需要我们了解函数的入参规则**就可以了。

### 缩小函数的元数-减少重复传参

偏函数不仅仅可以帮我们减少定义函数时的重复代码，还可以帮我们减少调用函数时的重复传参。

在 `generateSpecOrderData` 函数被定义出来之前，我在项目里见到了大量这样的代码：

```js
// 文件 a
const res = generateOrderData('food', 'hunan', normalSettlement)

// 文件 b
const UIData = generateOrderData('food', 'hunan', orderSettlement)  

// 文件 c  
const result = generateOrderData('food', 'hunan', couponSettlement)  
```

不同的调用，重复的传参，重复的 `food` + `hunan`。

而偏函数恰恰就可以把 `food` 和 `hunan` “记忆”下来，帮助我们避免这些重复。

实际上，通用函数为了确保其自身的灵活性，往往都具备“多元参数”的特征。但在一些特定的业务场景下，真正需要动态变化的只是其中的一部分的参数。这时候函数的一部分灵活性对我们来说是多余的，我们反而希望它的功能具体一点。

比如 `generateSpecOrderData` 函数，就对 `type` 和 `area` 并不感冒，只是想动态传入 `settlement` 而已。

这种场景下，偏函数出来扛大旗就再合适不过了。
