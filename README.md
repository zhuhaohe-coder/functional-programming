# 编程范式

> 编程范式可以理解为编程的风格/方式，它决定了我们将以一种什么样的方法和规范去组织自己的代码，是一门研究“如何写代码”的学问。

**JS是多范式的语言**

- 命令式编程
- 面向对象式编程
- 函数式编程

> 函数式编程是一种==强调以函数使用为主==的软件开发风格。 ——[美]路易斯·阿泰西奥

## 函数式编程三大特征

- 拥抱纯函数, 隔离副作用
- 函数是"一等公民"
- 避免对状态的改变(不可变值)

# 纯函数与副作用

## 纯函数

同时满足以下两个特征的函数，我们就认为是纯函数：

- 对于相同的输入，总是会得到相同的输出
- 在执行过程中没有语义上可观察的副作用。

## 副作用

> 在计算机科学中，**函数副作用**指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科

简单地讲：对函数来说，它的正常工作任务就是【**计算**】，除了计算之外，它不应该搞别的。

**如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。**

## 纯与不纯的本质

**“纯”的本质——有且仅有【显式数据流】**

> 纯函数（Pure Function）——输入输出数据流全是**显式**（Explicit）的函数。
> —— 维基百科

数据以入参形式传入，这叫【显式输入数据流】。

数据以返回值形式输出，这叫【显式输出数据流】。

> 纯函数——**输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，==不以任何其它形式和外界进行数据交换==的函数**。

**“不纯”的元凶——隐式数据流**

一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

# 函数是一等公民

> 当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有**头等函数**。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。 ——MDN Web Docs

头等函数的核心特征是“**可以被当做变量一样用**”。

它意味着：

1. 可以被当做参数传递给其他函数
2. 可以作为另一个函数的返回值
3. 可以被赋值给一个变量

## “一等公民”的本质

为什么 JS 中的函数这么牛x，可以为所欲为呢？

本质上是因为**它不仅仅是个函数，它还是个(可执行的)对象**。

```js
const func = ()=>{}
undefined
func instanceof Function
true
func instanceof Object
true
Function instanceof Object
true
```

JavaScript 有且仅有以下 8 种数据类型：

基本类型:**大小固定、体积轻量、相对简单。**

- Undefined 类型
- Null 类型
- Boolean 类型
- Number 类型
- String 类型
- Symbol 类型
- BigInt类型

引用类型:**复杂、占用空间较大、且大小不定。**

- Object 类型

这两类数据之间最大的区别，在于**变量保存了数据之后，我们还能对这个数据做什么**。

> **并没有一种数据类型叫 Function**，Function 和 Array、Date 这些 built-in Class 一样，都属于对象类型。
>
> 既然函数也是对象，那么对象能干的事，函数也能干。

# 不可变数据

> “不可变数据”正如一顶牢牢扣在我们程序员脑袋上的**安全帽**，它从实践的角度，对我们的编码行为作出了更加具体的约束，确保我们能够最大限度地输出纯净、安全的代码。

## 不可变的值

**值类型的数据无法被修改**，当我们修改值类型变量的时候，本质上会创建一个新的值。

```js
let a = 1
let b = a

// true
a === b

b = 2

// false
a === b
```

**像数字类型这样，自创建起就无法再被修改的数据，我们称其为“不可变数据**”。

## 可变的引用内容

**在引用本身不变的情况下，引用所指向的内容是可以发生改变的。**

```js
const a = {
  name: 'xiuyan',
  age: 30
}

const b = a


// true 
a === b 

b.name = 'youhu'   
 
// true
a === b 
```

**像这种创建后仍然可以被修改的数据，我们称其为“可变数据”。**

## 为什么函数式编程不喜欢可变数据

### 可变数据使函数行为变得难以预测

可变数据会使数据的变化变得隐蔽，进而使函数的行为变得难以预测。

在函数式编程这种范式下，我们校验一个函数有效性的关键依据，永远是“**针对已知的输入，能否给出符合预期的输出**”，这样的校验非常清晰、且容易实现。

而可变数据的出现则将会使函数的作用边界变得模糊，进而导致使用者、甚至开发者自身都难以预测它的行为最终会指向什么样的结果。

### 可变数据使函数复用成本变高

可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。

但很多情况下，当我们使用某一个函数的时候，我们会默认它是一个黑盒——无论是我今天去 npm 上拉下来一个第三方包，还是说我去其他业务的文件夹下借隔壁老王写的函数来用，我们关注的都是这个**函数的效用、函数的输入与输出，而不会去关注它的实现细节**。

就好像我们使用酸奶机之前，最多读一下说明书，而不会拆开它的壳子研究一下它装了几根电阻丝一样。

因此，我们有必要确保，这个黑盒是可靠的、受控的。

**一个可靠、受控的黑盒，应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西**。
这就像我们往酸奶机里倒入了酵母和牛奶，只期望它能产出酸奶，而不希望它引燃旁边的烤箱一样。

要想做到这一点，就必须**把可变数据从我们的函数代码里铲除干净。**

## 实践原则: 拷贝,而不是修改

### 拷贝的目的：确保外部数据的只读性

对于函数式编程来说，**函数的外部数据是只读的，函数的内部数据则是可写的**。

对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些**外部数据**，存在【只读】的必要。

> 注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。

### 拷贝不是万能解药

当**数据规模大、数据拷贝行为频繁**时，拷贝将会给我们的应用性能带来巨大的挑战。

拷贝出来的冗余数据将盘踞大量的内存，挤占其它任务的生存**空间**；此外，拷贝行为本身也是需要吃 CPU 的，持续而频繁的拷贝动作，无疑将拖慢应用程序的反应**速度**。

因此，对于**状态简单、逻辑轻量**的应用来说，拷贝确实是一剂维持数据不可变性的良药。

但是对于**数据规模巨大、数据变化频繁**的应用来说，拷贝意味着一场性能灾难。

## 持久化数据结构

### Immutable.js

> ImmutableJS 是对“不可变值”这一思想的贯彻实践。它在 2014 年被 Facebook 团队推出，Facebook 给它的定位是“实现持久化数据结构的库”。

mmutable.js 提供了一系列的 Api，这些 Api 将帮助我们确保数据的不可变性。

从代码上来看，它省掉了我们手动拷贝的麻烦。

从效率上来说，它在**底层应用了持久化数据结构，解决了暴力拷贝带来的各种问题**。

### Git “快照”是如何工作的

在创建 commit 时，git 会对整个项目的所有文件做一个“快照”。

“快照”记录的并不是文件的内容，而是**文件的索引**。

当 commit 发生时， git 会保存当前版本所有文件的索引。

**对于那些没有发生变化的文件，git 保存他们原有的索引；对于那些已经发生变化的文件，git 会保存变化后的文件的索引。**

假设一个项目中有 A、B 两个文件，其中 A 文件被修改了，而 B 文件保持不变。

我们将修改后的新的 A 文件的索引记为 A'

在变化发生后，A 和 A' 是共存的，变化前的那一次快照指向 A，变化后的这一次快照指向 A'。

而未被修改到的 B 文件，将会原封不动地呆在原地，被新版本的快照所复用，如下图所示：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bd7ddec61a48aa8ba293694f5707cc~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

**快照的本质是对索引的记录。**

### 理解“数据共享”：从“快照”到“安全帽”

和 git “快照”一样，持久化数据结构的精髓同样在于“**数据共享**”。

数据共享意味着将“变与不变”分离，确保**只有变化的部分被处理，而不变的部分则将继续留在原地、被新的数据结构所复用。**

## Immer.js

Immer.js 实现 Immutability 的姿势非常有趣——它使用 Proxy，对目标对象的行为进行“元编程”。

所谓“元编程”，指的是对编程语言进行再定义。

### 回顾Proxy

> Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 ——MDN

借助 Proxy，我们可以给目标对象创建一个代理（拦截）层、拦截原生对象的某些默认行为，进而实现对目标行为的自定义。

### Produce 工作原理：将拷贝操作精准化

`produce` 可以像 Immutable.js 一样，精准打击那些需要执行写操作的数据。**将“变与不变”分离，确保只有变化的部分被处理，而不变的部分则将继续留在原地。**

但 `produce` 并没有像 Immutable.js 一样打数据结构的主意，而是将火力集中对准了“拷贝”这个动作。

它严格地控制了“拷贝”发生的时机：**当且仅当写操作确实发生时，拷贝动作才会被执行。**

```js
const baseHandler = {
  set(obj, key, value) {
    // 先检查 copy 是否存在，如果不存在，创建 copy
    if (!copy) {
      copy = { ...base }
    }
    // 如果 copy 存在，修改 copy，而不是 base
    copy[key] = value
    return true
  }
}
```

在我们的极简版 `produce` 里，着重突出了 `setter` 函数的写逻辑，也就是对“拷贝时机”的描述，淡化了其它执行层面的细节。

而在 Immer.js 中，完整版 `produce` 的浅拷贝其实是**可递归**的。

`produce` **不仅会拦截** `setter` **，也会拦截** `getter`。

通过对 `getter` 的拦截，`produce` 能够按需地对被访问到的属性进行“懒代理”：你访问得有多深，代理逻辑就能走多深；而所有被代理的属性，都会具备新的 `setter` 方法。

当写操作发生时，`setter` 方法就会被逐层触发，呈现“逐层浅拷贝”的效果。

**“逐层浅拷贝”是 Immer 实现数据共享的关键。**

假设我的对象嵌套层级为 10 层，而我对它的属性修改只会触达第 2 层，“逐层的浅拷贝”就能够帮我们确保拷贝只会进行到第 2 层。

“逐层的浅拷贝”如果递归到最后一层，就会变成深拷贝。

对于引用类型数据来说，“暴力拷贝”指的也就是深拷贝。

“暴力拷贝”之所以会带来大量的时间空间上的浪费，本质上是因为它在拷贝的过程中不能够“**知其所止**”。

而“逐层的浅拷贝”之所以能够实现数据共享，正是因为它借助 Proxy 做到了“**知其所止**”。

### “知其所止”的软件设计表达

无论是“精准拷贝”、“修改时拷贝”，还是“逐层拷贝”，其背后体现的都是同一个思想——“按需”。

“知其所止”的软件设计表达，就是“按需”。

对于 Immutable.js 来说，它通过构建一套原生 JS 无法支持的 Trie 数据结构，最终实现了树节点的按需创建。

对于 Immer.js 来说，它借助 Proxy 的 getter 函数实现了按需代理，借助 Proxy 的 setter 函数实现了对象属性的按需拷贝。

可见，想要实现高效的 Immutability，“按需变化”是一个不错的切入点。

## Immutability 的实践演进

对于 JS 来说，Immutability 实践的直接目的是什么？

简单来说，是为了解决**数据内容变化与数据引用变化不同步的问题**。

我拿到一个引用类型数据（`A`)，修改了其中的一个 `a` 属性，然后所有依赖 `A.a` 进行计算的函数逻辑全炸了，牵一发而动全身，这不是我们想要的结局。

我们希望一旦引用类型数据（`A`）的内容改变了，我们就能获取到一个新的引用，这个引用指向一套已经发生改变的数据（`A'`)， `A` 和 `A'` 应该是泾渭分明的。

**暴力拷贝，可以做到“泾渭分明”，但是对于规模较大的数据来说，它太低效了**。

于是，社区的 Immutability 解决方案百花齐放，Immer.js 和 Immutable.js 就是其中的佼佼者。

**Immutable.js 底层是持久化数据结构，而 Immer.js 的底层是 Proxy 代理模式。**

两者虽然在具体的工作原理上大相径庭，但最终指向的目的却是一致的：**使数据的引用与数据内容的变化同步发生；并且在这个过程中，按需处理具体的变化点，提升不可变数据的执行效率。**

# 因为DRY,所以HOF

> DRY(Don't Repeat Yourself) 是一种软件设计原则，HOF(High Order Function)指高阶函数。

**高阶函数，指的就是接收函数作为入参，或者将函数作为出参返回的函数。**

## WHY HOF

- 更简洁的代码,方便读写
- 更小的编码负担
- 更好的可读性
- 代码可复用, 利人利己
- 清晰的逻辑边界, 更少的测试工作

# "万金油"Reduce

> `reduce()`**是函数式语言的万金油；函数式语言不能失去** `reduce()`**，就像西方不能失去耶路撒冷。**

**在 JS 中，基于 reduce()，我们不仅能够推导出其它数组方法，更能够推导出经典的函数组合过程。**

## 使用reduce推导map

```js
const reduceToMap = (arr, fn) => {
  return arr.reduce((pre, cur) => {
    pre.push(fn(cur));
    return pre;
  }, []);
};
```

`map()` 过程可以看作是 `reduce()` 过程的一种特殊的应用。

也就是说，在数组方法里，`reduce()` 处在逻辑链相对底层的位置，这一点毋庸置疑。

`reduce()`**真正的威力，在于它对函数组合思想的映射。**

## `reduce()` 映射了函数组合思想

`reduce()` 的工作流：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd3b69f006824035ac674303fe2c0feb~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

通过观察这个工作流，我们可以发现这样两个特征：

- `reduce()` 的回调函数在做参数组合
- `reduce()` 过程构建了一个函数 pipeline

### `reduce()` 的回调函数在做参数组合

首先，就 reduce() 过程中的单个步骤来说，每一次回调执行，都会吃进 2 个参数，吐出 1 个结果。

我们可以把每一次的调用看做是把 2 个入参被【**组合**】进了 callback 函数里，最后转化出 1 个出参的过程。

我们把数组中的 n 个元素看做 n 个参数，那么 `reduce()` 的过程，就是一个把 n 个参数逐步【**组合**】到一起，最终吐出 1 个结果的过程。

reduce，动词，意为减少。这个【减少】可以理解为是参数个数的减少。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc3554f1f1245c5bdaa8d3647411b90~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

如上图所示，reduce 方法把多个入参，reduce（减少）为一个出参 。

### `reduce()` 过程是一个函数 pipeline

`reduce()` 函数发起的工作流，可以看作是一个函数 pipeline。

尽管每次调用的都是同一个函数，但**上一个函数的输出，总是会成为下一个函数的输入。**

同时，`reduce()` pipeline 里的每一个任务都是一样的，仅仅是入参不同，**这极大地约束了 pipeline 的能力**。

我们把 `reduce()` 的这两个特征放在一起来看：**参数组合+函数pipeline**。

咱就是说，有没有可能，有没有可能咱们把 pipeline 里的每一个函数也弄成不一样的呢？

更直白地说，你`reduce()`既然都能组合参数了，你能不能帮我的 pipeline 组合一下函数呢？

毕竟，**JS 的函数是可以作为参数传递**的嘛！

答案是肯定的——可能，可太能了！

`reduce()` 之所以能够作为函数式编程的“万金油”存在，本质上就是因为它映射了函数组合的思想。

而函数组合，恰恰是函数式编程中最特别、最关键的实践方法，是核心中的核心，堪称“核中核”。

# 声明式数据流:从链式调用到回调地狱

## 借助链式调用构建声明式数据流

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8];
/*
筛选出 arr 里大于 2 的数字
将步骤1中筛选出的这些数字逐个乘以 2
对步骤 2 中的偶数数组做一次求和
*/
const arrMoreThan2 = arr.filter((item) => item > 2);
const arrMutile2 = arrMoreThan2.map((item) => item * 2);
const arrSum = arrMutile2.reduce((pre, cur) => {
  return pre + cur;
}, 0);
console.log(arrSum);//66

//code review
/*
 1.简洁性:
 冗余常量arrMoreThan2,arrMutile2(计算中间态)
 拉垮了代码的可读性

 2.安全性:
 arrMoreThan2,arrMutile2作为引用类型,完全有可能在运行过程中被修改
 不要抱计算中间态暴露出去
*/
//优化
const biggerThan2 = (num) => num > 2;
const mutile2 = (num) => num * 2;
const add = (a, b) => a + b;
const sum = arr.filter(biggerThan2).map(mutile2).reduce(add, 0);
console.log(sum);//66
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e1de59b45848e0982ba71d67c99de3~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

**借助链式调用，足以完美地规避掉那些尴尬的“中间态”，从而确保我们的代码简洁安全。**

过去，我有三行代码，我需要逐行阅读、理解计算中间态和主流程之间的逻辑关系，才能够推导出程序的意图。**这样的代码，是命令式的。**

现在，我只需要观察一个函数调用链，这个调用链如同一条传送带一般，用函数名标注了每道工序的行为。即便不清楚数据到底是如何在“传送带”上流转的，我们也能够通过函数名去理解程序的意图。

**这样的代码，是声明式的。** 基于此构建出的数据流，就是**声明式的数据流**。

**实现声明式的数据流，除了借助链式调用，还可以借助函数组合。**

### 链式调用的前提

map()、reduce()、filter() 这些方法之间，之所以能够进行链式调用，是因为：

1. 它们都**挂载在 Array 原型的 Array.prototype** 上
2. 它们在计算结束后都会 return 一个新的 Array
3. 既然 return 出来的也是 Array，那么自然可以继续访问原型 **Array.prototype** 上的方法

链式调用的本质 **，是通过在方法中==返回对象实例本身的 this/ 与实例 this 相同类型的对象==，达到多次调用其原型（链）上方法的目的。**

要对函数执行链式调用，**前提是==函数挂载在一个靠谱的宿主 Object 上==。**

## 独立函数的组合姿势

```js
function add4(num) {
  return num + 4;
}

function multiply3(num) {
  return num * 3;
}

function divide2(num) {
  return num / 2;
}
//如何基于这些独立函数，构建一个多个函数串行执行的工作流？
```

### 组合，但是回调地狱版

```js
// 1.套娃--反复去嵌套各种回调函数  回调地狱
const res = add4(multiply3(divide2(10)));
console.log(res);
```

