# 编程范式

> 编程范式可以理解为编程的风格/方式，它决定了我们将以一种什么样的方法和规范去组织自己的代码，是一门研究“如何写代码”的学问。

**JS是多范式的语言**

- 命令式编程
- 面向对象式编程
- 函数式编程

> 函数式编程是一种==强调以函数使用为主==的软件开发风格。 ——[美]路易斯·阿泰西奥

## 函数式编程三大特征

- 拥抱纯函数, 隔离副作用
- 函数是"一等公民"
- 避免对状态的改变(不可变值)

# 纯函数与副作用

## 纯函数

同时满足以下两个特征的函数，我们就认为是纯函数：

- 对于相同的输入，总是会得到相同的输出
- 在执行过程中没有语义上可观察的副作用。

## 副作用

> 在计算机科学中，**函数副作用**指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科

简单地讲：对函数来说，它的正常工作任务就是【**计算**】，除了计算之外，它不应该搞别的。

**如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。**

## 纯与不纯的本质

**“纯”的本质——有且仅有【显式数据流】**

> 纯函数（Pure Function）——输入输出数据流全是**显式**（Explicit）的函数。
> —— 维基百科

数据以入参形式传入，这叫【显式输入数据流】。

数据以返回值形式输出，这叫【显式输出数据流】。

> 纯函数——**输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，==不以任何其它形式和外界进行数据交换==的函数**。

**“不纯”的元凶——隐式数据流**

一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-jj-mark:2268:0:0:0:q75.awebp)

# 函数是一等公民

> 当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有**头等函数**。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。 ——MDN Web Docs

头等函数的核心特征是“**可以被当做变量一样用**”。

它意味着：

1. 可以被当做参数传递给其他函数
2. 可以作为另一个函数的返回值
3. 可以被赋值给一个变量

## “一等公民”的本质

为什么 JS 中的函数这么牛x，可以为所欲为呢？

本质上是因为**它不仅仅是个函数，它还是个(可执行的)对象**。

```js
const func = ()=>{}
undefined
func instanceof Function
true
func instanceof Object
true
Function instanceof Object
true
```

JavaScript 有且仅有以下 8 种数据类型：

基本类型:**大小固定、体积轻量、相对简单。**

- Undefined 类型
- Null 类型
- Boolean 类型
- Number 类型
- String 类型
- Symbol 类型
- BigInt类型

引用类型:**复杂、占用空间较大、且大小不定。**

- Object 类型

这两类数据之间最大的区别，在于**变量保存了数据之后，我们还能对这个数据做什么**。

> **并没有一种数据类型叫 Function**，Function 和 Array、Date 这些 built-in Class 一样，都属于对象类型。
>
> 既然函数也是对象，那么对象能干的事，函数也能干。

# 不可变数据

> “不可变数据”正如一顶牢牢扣在我们程序员脑袋上的**安全帽**，它从实践的角度，对我们的编码行为作出了更加具体的约束，确保我们能够最大限度地输出纯净、安全的代码。

## 不可变的值

**值类型的数据无法被修改**，当我们修改值类型变量的时候，本质上会创建一个新的值。

```js
let a = 1
let b = a

// true
a === b

b = 2

// false
a === b
```

**像数字类型这样，自创建起就无法再被修改的数据，我们称其为“不可变数据**”。

## 可变的引用内容

**在引用本身不变的情况下，引用所指向的内容是可以发生改变的。**

```js
const a = {
  name: 'xiuyan',
  age: 30
}

const b = a


// true 
a === b 

b.name = 'youhu'   
 
// true
a === b 
```

**像这种创建后仍然可以被修改的数据，我们称其为“可变数据”。**

## 为什么函数式编程不喜欢可变数据

### 可变数据使函数行为变得难以预测

可变数据会使数据的变化变得隐蔽，进而使函数的行为变得难以预测。

在函数式编程这种范式下，我们校验一个函数有效性的关键依据，永远是“**针对已知的输入，能否给出符合预期的输出**”，这样的校验非常清晰、且容易实现。

而可变数据的出现则将会使函数的作用边界变得模糊，进而导致使用者、甚至开发者自身都难以预测它的行为最终会指向什么样的结果。

### 可变数据使函数复用成本变高

可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。

但很多情况下，当我们使用某一个函数的时候，我们会默认它是一个黑盒——无论是我今天去 npm 上拉下来一个第三方包，还是说我去其他业务的文件夹下借隔壁老王写的函数来用，我们关注的都是这个**函数的效用、函数的输入与输出，而不会去关注它的实现细节**。

就好像我们使用酸奶机之前，最多读一下说明书，而不会拆开它的壳子研究一下它装了几根电阻丝一样。

因此，我们有必要确保，这个黑盒是可靠的、受控的。

**一个可靠、受控的黑盒，应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西**。
这就像我们往酸奶机里倒入了酵母和牛奶，只期望它能产出酸奶，而不希望它引燃旁边的烤箱一样。

要想做到这一点，就必须**把可变数据从我们的函数代码里铲除干净。**